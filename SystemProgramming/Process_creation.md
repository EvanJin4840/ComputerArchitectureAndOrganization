### Context switching?

CPU가 지금까지 실행하던 프로세스의 실행 상태(context)를 저장하고, 다른 프로세스의 상태를 불러와서 실행을 넘겨주는 것

- Context란?
  프로세스가 어디까지 실행됐고, 다음에 뭘 실행해야 하는지에 대한 상태
  예를 들어, CPU 레지스터 값, 프로그램 카운터(PC), 스택 포인터, 메모리 매핑 정보, 프로세스 상태 같은 것들이 들어있음.

그래서 커널은 다음 작업을 함

1. 지금 실행 중이던 프로세스의 컨텍스트 저장
2. 새로 실행할 프로세스의 컨텍스트 불러옴
3. CPU 실행 흐름을 새 프로세스로 넘김

### Exit handler?

프로세스가 종료될 때 자동으로 호출되는 "정리(Clean-up)함수들을 의미함.
C 표준 라이브러리에서 이를 atextit()로 등록한 함수라고 보면 됨.
즉, 프로그램이 끝나기 직전에 한 번 더 실행해야 할 사용자 정의 함수들

## background process vs foreground process

- foreground process
  사용자와 직접 상호작용하며 터미널 창을 점유하고 있는 상태입니다. (1번에 딱 하나밖에 없음, 순간 순간 바뀔 수 있음.)

* 동작: 명령어를 입력하면 프로그램이 끝날 때까지 터미널에 결과가 출력되고, 사용자는 프로그램이 종료되기 전까지 다른 명령어를 입력할 수 없습니다.
* 특징: 사용자의 키보드 입력(Standard Input)을 직접 받습니다.

- background process
  사용자의 눈에 보이지 않게 뒤에서 묵묵히 실행되는 상태입니다.

* 동작: 프로세스가 실행되는 동안 터미널 창이 자유롭습니다. 즉, 프로그램이 돌아가는 와중에도 사용자는 다른 명령어를 계속 입력할 수 있습니다.
* 특징: 터미널 창(입출력 장치)을 점유하지 않습니다. 웹 서버나 데이터베이스처럼 계속 켜져 있어야 하는 프로그램에 주로 사용됩니다.

#### signal pending and blocked

1. 인터럽트(Interrupt): 하드웨어의 엄격한 줄 세우기
   하드웨어 인터럽트는 CPU가 놓치면 안 되는 중요한 사건(키보드 입력, 네트워크 패킷 도착 등)을 다룹니다.

큐(Queue) 관리: 인터럽트는 CPU의 하드웨어 레벨이나 커널의 인터럽트 컨트롤러에 의해 큐에 쌓이거나 우선순위에 따라 관리됩니다.

순차 처리: 인터럽트가 발생하면 CPU는 현재 작업을 멈추고 해당 인터럽트 서비스 루틴(ISR)을 실행합니다. 그동안 다른 인터럽트가 들어오면 우선순위에 따라 대기열에 기록되어 하나씩 순서대로 처리되는 것이 원칙입니다.

2. 시그널(Signal): 소프트웨어의 "상태 표시(Flag)" 방식
   반면, 리눅스 시그널(표준 시그널 기준)은 조금 더 단순한 방식을 취합니다. 커널은 각 프로세스에 대해 **"어떤 시그널이 왔는가"를 비트보드(Bitboard)**에 체크하는 방식으로 기록합니다.

중복의 소멸: 동일한 종류의 시그널(예: SIGCHLD)이 짧은 시간 안에 10번 발생하더라도, 커널은 해당 프로세스의 시그널 비트마스크에서 해당 시그널 칸을 **'1'(발생함)**로 바꿀 뿐입니다.

최근 것만 유효한 이유: 이미 '1'로 체크되어 있는데 똑같은 시그널이 또 오면, 여전히 '1'일 뿐입니다. 즉, "시그널이 몇 번 왔는지"는 기록되지 않고 "왔다"는 사실만 기록됩니다.

처리 시점: 프로세스가 제어권을 받아 시그널 핸들러를 실행할 때, 비트가 체크된 것을 보고 "아, 이 시그널이 왔구나" 하고 처리합니다. 이때 한 번에 한 번의 핸들러만 실행되므로, 10번의 신호가 1번의 처리로 뭉쳐버릴 수 있습니다.

- 번호별로 각각 하나씩은 동시에 Pending 될 수 있습니다. (9번 1개 + 2번 1개 + ... 가능)

* 하지만 같은 번호의 시그널은 여러 개가 동시에 Pending 될 수 없습니다. (9번이 이미 있으면 새로 오는 9번은 사라짐)
